# 关于for循环和setTimeout
在前端中经常会遇到这样一个问题
```
for(var i = 0; i < 5; i++){
    setTimeout(function(){
        console.log(i);
    },1000);
}
```
其实很简单了，我想这个题目的本意是想在一秒后输出，
```
0,1,2,3,4
```
但是其实输出的是
```
5,5,5,5,5
```

这个题之所以会被用这么多，确实是因为他考察了很多方面的知识，包括 异步、声明、函数。  
先看异步，如果想知道为什么会输入5个5，就要先了解js的异步运行，一般可以按照以下规则去理解。  

js先执行主线程的同步事件，再执行异步的回调，主线程没执行完，就不会执行异步的回调，即使回调已经完成了。

举个例子
```
setTimeout(function(){
    alert('timeout');
},0)
function fn(n){    
    if(n<=2){    
        return 1;    
    }else{    
        return fn(n-1)+fn(n-2);    
    }    
}    
alert(fn(45));
```
函数fn至少要运行十几秒，而setTimeout的异步回调是0s后运行。  
但是你依然会发现，js会先输出`fn(45)`的运行结果，再输出`timeout`。  
由此可以看出，异步是在同步运行完成之后在运行的。

回到上面的问题，for循环是同步运行，setTimeout的回调是异步运行，先循环完毕，在运行五次回调函数。  
那么问题就很明显，循环结束后，i已经为5。此时再运行回调函数，获取的全部都是5;  

怎么解决？
```
function runSetTimeout(i){
    setTimeout(function(){
        console.log(i);
    },1000);
}

for(var i = 0; i < 5; i++){
    runSetTimeout(i);
}
```
在这里，每次循环去运行一个函数，并且把i的值传递过去，就可以解决，
因为每次循环执行的函数都是有独立的作用域的。而传参时候，会把i值复制到runSetTimeout的作用域内部。
这个值不会被外部的循环改变，属于每个函数运行时独有的。 


既然我们知道了和作用域有关，还有什么方法可以用呢
```
for(let i = 0; i < 5; i++){
    setTimeout(function(){
        console.log(i);
    },1000);
}
```
把`var`改为`let`。 因为`var`的声明没有块级作用域，而let是有的。  
最后,为什么直接输出的是5,而不是4，这个可以参考高三上面的关于 ++i和i++的区别。